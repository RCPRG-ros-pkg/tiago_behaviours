#!/usr/bin/env python
# encoding: utf8

import sys

import rospy
import smach
import smach_ros

import tiago_smach.conversation
import tiago_smach.human_fell
import tiago_smach.smach_rcprg as smach_rcprg
from tiago_smach.dynamic_agent_tasker import DynAgent

import tiago_kb.places_xml as kb_p

from tiago_smach.task_manager import PoseDescription

from pl_nouns.dictionary_client import DisctionaryServiceClient

from TaskER.msg import RobotResource, ScheduleParams
from TaskER.srv import SuspendConditionsRequest, SuspendConditionsResponse
from TaskER.srv import CostConditionsRequest, CostConditionsResponse
# for ExeSuspension state
import subprocess
import imp

class Cleanup(smach_rcprg.State):
    def __init__(self, conversation_interface, da_state_name):
        self.conversation_interface = conversation_interface
        da_state_name = "Cleanup"
        smach_rcprg.State.__init__(self, outcomes=['ok', 'shutdown'])

    def execute(self, userdata):
        rospy.loginfo('{}: Executing state: {}'.format(rospy.get_name(), self.__class__.__name__))
        print 'Cleanup.execute'
        self.conversation_interface.stop()
        return 'ok'

class GetSuspension(smach_rcprg.State):
    def __init__(self, conversation_interface, da_state_name):
        self.conversation_interface = conversation_interface
        da_state_name = "GetSuspension"
        smach_rcprg.State.__init__(self, outcomes=['ok'], output_keys=['fsm_es_out'])

    def execute(self, userdata):
        rospy.loginfo('{}: Executing state: {}'.format(rospy.get_name(), self.__class__.__name__))
        print 'GetSuspend.execute'
        print "susp data: ", userdata.susp_data.getData()
        print "susp data[0]: ", userdata.susp_data.getData()[0]
        data = userdata.susp_data.getData()
        fsm_executable = None
        for idx in range(2, len(data), 2):
            print data[idx]
            if data[idx] == 'executable':
                fsm_executable = data[idx+1]
        if fsm_executable == None:
            print "harmoniser did not specified executable for suspension behaviour, terminating task"
            fsm_executable = "terminate task"
        userdata.fsm_es_out = fsm_executable
        userdata.susp_data.clearData()
        #srv.shutdown()
        rospy.sleep(5)
        return 'ok'

class ExeSuspension(smach_rcprg.State):
    def __init__(self, conversation_interface, da_state_name):
        self.conversation_interface = conversation_interface
        da_state_name = "ExeSuspension"

        smach_rcprg.State.__init__(self, outcomes=['ok', 'shutdown'],input_keys=['fsm_es_in'])

    def execute(self, userdata):
        rospy.loginfo('{}: Executing state: {}'.format(rospy.get_name(), self.__class__.__name__))
        print 'ExecSuspension.execute'
        #srv.shutdown()
        print userdata.fsm_es_in
        if userdata.fsm_es_in == "fsm_executable":
            return 'shutdown'

        p = subprocess.Popen(userdata.fsm_es_in , shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        # and you can block util the cmd execute finish
        p.wait()
        # or stdout, stderr = p.communicate()
        return 'ok'
class Wait(smach_rcprg.State):
    def __init__(self, conversation_interface, da_state_name):
        self.conversation_interface = conversation_interface
        da_state_name = "Wait"


        smach_rcprg.State.__init__(self, outcomes=['start', 'terminate'])

    def execute(self, userdata):
        rospy.loginfo('{}: Executing state: {}'.format(rospy.get_name(), self.__class__.__name__))
        print 'Wait.execute'
        #srv.shutdown()
        fsm_cmd = None

        while not fsm_cmd == "resume":
            data = userdata.susp_data.getData()
            for idx in range(0, len(data), 2):
                print data[idx]
                if data[idx] == 'cmd':
                    fsm_cmd = data[idx+1]
            if self.preempt_requested():
                return 'terminate'
            rospy.sleep(1)
        return 'start'

class UpdateTask(smach_rcprg.State):
    def __init__(self, conversation_interface, da_state_name):
        self.conversation_interface = conversation_interface
        da_state_name = "UpdateTask"
        smach_rcprg.State.__init__(self, outcomes=['ok', 'shutdown'])

    def execute(self, userdata):
        rospy.loginfo('{}: Executing state: {}'.format(rospy.get_name(), self.__class__.__name__))
        print 'UpdateTask.execute'
        rospy.sleep(3)
        #srv.shutdown()
        return 'ok'
#
# The SM that govenrs the highest-level behaviour.
#

class MainSM(smach_rcprg.StateMachine):
    def __init__(self, da_state_name):
        smach_rcprg.StateMachine.__init__(self, da_state_name=da_state_name, outcomes=['Finished', 'shutdown'], input_keys=[], output_keys=[])
        places_xml_filename = rospy.get_param('/kb_places_xml')
        sim_mode = str(rospy.get_param('/sim_mode'))
        assert sim_mode in ['sim', 'gazebo', 'real']

        print 'Reading KB for places from file "' + places_xml_filename + '"'
        kb_places = kb_p.PlacesXmlParser(places_xml_filename).getKB()

        if len(sys.argv) < 3:
            raise Exception('Too few arguments: ' + str(sys.argv))

        goods_name = None
        for idx in range(1, len(sys.argv), 2):
            if sys.argv[idx] == 'przedmiot':
                goods_name = sys.argv[idx+1]

        if goods_name is None:
            raise Exception('Argument "goods_name" is missing in argv: ' + str(sys.argv))        

        if isinstance(goods_name, str):
            goods_name = goods_name.decode('utf-8')
        goods_name = goods_name.encode('utf-8').decode('utf-8')

        dictionary = DisctionaryServiceClient()
        goods_name_m = dictionary.getCases(goods_name).getCase('mianownik')

        self.conversation_interface = tiago_smach.conversation.ConversationMachine([
                ('ack',             'projects/incare-dialog-agent/agent/intents/ef92199b-d298-470c-8df3-1e1047dd70d1'),
                ('ack_i_took',      'projects/incare-dialog-agent/agent/intents/181621b6-e91e-4244-a925-c5dc32ee1f1b'),
                ('ack_i_gave',      'projects/incare-dialog-agent/agent/intents/d017cbd0-93f8-45b2-996e-043cdccab629'),
                ('q_current_task',  'projects/incare-dialog-agent/agent/intents/8f45359d-ee47-4e10-a1b2-de3f3223e5b4'),
                ('q_load',          'projects/incare-dialog-agent/agent/intents/b8743ab9-08a1-49e8-a534-abb65155c507'),
                ('turn_around',     'projects/incare-dialog-agent/agent/intents/b4cb9f2e-2589-44dd-af14-a8f899c40ec0'),
            ])
        self.conversation_interface.start()

        self.userdata.goal = goods_name_m
        self.userdata.fsm_es = ""
        
        with self:
            smach_rcprg.StateMachine.add('ExecFSM',
                                    tiago_smach.bring_goods.BringGoods(sim_mode, self.conversation_interface, kb_places),
                                    transitions={'FINISHED':'Cleanup', 'PREEMPTED':'GetSuspension', 'FAILED': 'Cleanup',
                                    'shutdown':'shutdown'},
                                    remapping={'goal':'goal', 'susp_data':'susp_data'})
            smach_rcprg.StateMachine.add('GetSuspension',
                                    GetSuspension(self.conversation_interface, da_state_name),
                                    transitions={'ok':'ExeSuspension'},
                                    remapping={'susp_data':'susp_data', 'fsm_es_out':'fsm_es'})
            smach_rcprg.StateMachine.add('ExeSuspension',
                                    ExeSuspension(self.conversation_interface, da_state_name),
                                    transitions={'ok':'Wait', 'shutdown':'shutdown'},
                                    remapping={'susp_data':'susp_data','fsm_es_in':'fsm_es'})
            smach_rcprg.StateMachine.add('Wait',
                                    Wait(self.conversation_interface, da_state_name),
                                    transitions={'start':'UpdateTask', 'terminate':'Cleanup'},
                                    remapping={'susp_data':'susp_data'})
            smach_rcprg.StateMachine.add('UpdateTask',
                                    UpdateTask(self.conversation_interface, da_state_name),
                                    transitions={'ok':'ExecFSM', 'shutdown':'shutdown'},
                                    remapping={'susp_data':'susp_data'})
            smach_rcprg.StateMachine.add('Cleanup',
                                    Cleanup(self.conversation_interface, da_state_name),
                                    transitions={'ok':'Finished', 'shutdown':'shutdown'},
                                    remapping={ })


    def shutdownRequest(self):
        self.conversation_interface.stop()
        self.request_preempt()
    def handleSuspension(self, data):
        print "handling suspension with data: ", data
def ptf_csp(ptf_id):
    print "calculating SP: ", ptf_id
    if ptf_id[0] == "scheduleParams":
        return ScheduleParams(cost = 10, completion_time=1,cost_per_sec=1,final_resource_state=RobotResource())
    elif ptf_id[0] == "suspendCondition":
        req = SuspendConditionsRequest()
        req = ptf_id[1]
        return SuspendConditionsResponse(cost_per_sec=1, cost_to_resume=1)
    elif ptf_id[0] == "startCondition":
        req = CostConditionsRequest()
        req = ptf_id[1]
        return CostConditionsResponse(cost_per_sec=1, cost_to_complete=1)
class MyTaskER(smach_rcprg.TaskER):
    def __init__(self,da_state_name, da_name):
        self.name = unicode(da_name)
        self.sim_mode = None
        self.conversation_interface = None
        self.kb_places = None
        smach_rcprg.TaskER.__init__(self,da_state_name)
        self.sis = smach_ros.IntrospectionServer(unicode(str("/"+self.name+"smach_view_server")), self, unicode(self.name))
        self.sis.start()
        places_xml_filename = rospy.get_param('/kb_places_xml')
        self.sim_mode = str(rospy.get_param('/sim_mode'))
        assert self.sim_mode in ['sim', 'gazebo', 'real']

        print 'Reading KB for places from file "' + places_xml_filename + '"'
        self.kb_places = kb_p.PlacesXmlParser(places_xml_filename).getKB()


        self.conversation_interface = tiago_smach.conversation.ConversationMachine([
                ('ack',             'projects/incare-dialog-agent/agent/intents/ef92199b-d298-470c-8df3-1e1047dd70d1'),
                ('ack_i_took',      'ack_i_took'),
                ('ack_i_gave',      'ack_i_gave'),
                ('q_current_task',  'projects/incare-dialog-agent/agent/intents/8f45359d-ee47-4e10-a1b2-de3f3223e5b4'),
                ('q_load',          'projects/incare-dialog-agent/agent/intents/b8743ab9-08a1-49e8-a534-abb65155c507'),
                ('turn_around',     'projects/incare-dialog-agent/agent/intents/b4cb9f2e-2589-44dd-af14-a8f899c40ec0'),
            ], self.sim_mode)
        self.my_fsm = tiago_smach.human_fell.HumanFell(self.sim_mode, self.conversation_interface, self.kb_places)
    def shutdownRequest(self):
        print ("my-tasker -----------------------   shutdown")
        self.conversation_interface.stop()
        self.sis.stop()
        self.sis.clear()
    def cleanup_tf(self):
        rospy.loginfo('{}: Executing state: {}'.format(rospy.get_name(), self.__class__.__name__))
        print 'Cleanup.execute'
        self.conversation_interface.stop()
        return 'ok'

    def get_suspension_tf(self,susp_data):
        print "My TASKER -- get_suspension_tf"
        print "My TASKER"
        print "My TASKER"
        rospy.loginfo('{}: Executing state: {}'.format(rospy.get_name(), self.__class__.__name__))
        print 'GetSuspend.execute'
        print "susp data: ", susp_data.getData()
        print "susp data[0]: ", susp_data.getData()[0]
        data = susp_data.getData()
        fsm_executable = None
        for idx in range(2, len(data), 2):
            print data[idx]
            if data[idx] == 'executable':
                fsm_executable = data[idx+1]
            elif data[idx] == 'rosrun':
                ros_pkg = data[idx+1]
                ros_exec = data[idx+2]
                fsm_executable = "rosrun "+ros_pkg+" "+ros_exec
        if fsm_executable == None:
            print "harmoniser did not specified executable for suspension behaviour, terminating task"
            fsm_executable = "terminate task"
        return fsm_executable

    def exe_suspension_tf(self,fsm_es_in):
        print "My TASKER -- exe_suspension_tf"
        print "My TASKER"
        print "My TASKER"
        rospy.loginfo('{}: Executing state: {}'.format(rospy.get_name(), self.__class__.__name__))
        print 'ExecSuspension.execute'
        #srv.shutdown()
        print fsm_es_in
        if fsm_es_in == "terminate task":
            return 'shutdown'
        else:
            p = subprocess.Popen(fsm_es_in , shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

            # and you can block util the cmd execute finish
            p.wait()
        return 'FINISHED'
    def wait_tf(self):
        print "My TASKER -- wait_tf"
        print "My TASKER"
        print "My TASKER"
        pass
    def update_task_tf(self):
        print "My TASKER -- update_task_tf"
        print "My TASKER"
        print "My TASKER"
        self.sis.stop()
        self.sis.clear()

        imp.reload(tiago_smach.human_fell)
        print "SWAPPING"
        self.swap_state('ExecFSM', tiago_smach.human_fell.HumanFell(self.sim_mode, self.conversation_interface, self.kb_places))
        self.sis.start()
        # self.my_fsm.set_initial_state(['MoveToKitchen'])
        pass
    def initialise_tf(self):
        print "My TASKER -- initialise"
        if len(sys.argv) < 3:
            raise Exception('Too few arguments: ' + str(sys.argv))

        goods_name = None
        for idx in range(1, len(sys.argv), 2):
            if sys.argv[idx] == 'human_name':
                human_name = sys.argv[idx+1]
        if human_name is None:
            raise Exception('Argument "human_name" is missing in argv: ' + str(sys.argv))      

        # if isinstance(goods_name, str):
        #     goods_name = goods_name.decode('utf-8')
        # goods_name = goods_name.encode('utf-8').decode('utf-8')

        # dictionary = DisctionaryServiceClient()
        # goods_name_m = dictionary.getCases(goods_name).getCase('mianownik')

        self.conversation_interface.start()

        self.userdata.human_name = human_name
        self.userdata.fsm_es = ""
def main():
    da_name = None
    da_type = None
    da_id = None
    da_state_name = []
    for idx in range(1, len(sys.argv), 2):
                if sys.argv[idx] == 'da_name':
                    da_name = sys.argv[idx+1]
                if sys.argv[idx] == 'da_type':
                    da_type = sys.argv[idx+1]
                if sys.argv[idx] == 'da_id':
                    da_id = sys.argv[idx+1]
    if da_name == None or da_type == None or da_id == None:
        print "DA: one of the parameters (<da_name>, <da_type>, or <da_id>) is not specified"
        return 1
    da = DynAgent( da_name, da_id, da_type, ptf_csp, da_state_name )
    print "RUN BRING"
    da.run( MyTaskER(da_state_name,da_name) )
    print "BG ENDED"
    return 0

if __name__ == '__main__':
    main()
    print "ALLLLLLL CLOOOOOSSSSEEEEED"
