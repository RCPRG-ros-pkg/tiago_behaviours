#!/usr/bin/env python

import sys
import time
import threading
import rospy
import smach
import smach_ros

from tiago_behaviours_msgs.msg import WanderAction, MoveToAction, BringGoodsAction, StopAction,\
                                        QuestionLoadAction, QuestionCurrentTaskAction, AckAction, AckItookAction, AckIgaveAction

import tiago_smach.bring_goods
import tiago_smach.navigation
import tiago_smach.wander

class Idle(smach.State):
    def __init__(self, action_names):
        outcomes = ['ok', 'preemption', 'error']
        for an in action_names:
            if an in outcomes:
                raise Exception('The action name "' + an + '" is already in outcomes.')
            outcomes.append( an )
        self.__pending_action__ = None

        smach.State.__init__(self, output_keys=['sm_goal'],
                                    outcomes=outcomes)

    def execute(self, userdata):
        rospy.loginfo('{}: Executing state: {}'.format(rospy.get_name(), self.__class__.__name__))
        print 'Idle.execute'

        while True:
            #print 'Idle.loop'
            if self.preempt_requested():
                # This state cannot be preempted
                self.service_preempt()
                return 'error'

            if self.hasPendingAction():
                action_name, sm_goal = self.takePendingAction()
                userdata.sm_goal = sm_goal
                print 'Idle: hasPendingAction: ' + action_name
                return action_name
            time.sleep(0.1)
        return 'error'

    def setPendingAction(self, action_name, sm_goal):
        self.__pending_action__ = ( action_name, sm_goal )

    def hasPendingAction(self):
        return not self.__pending_action__ is None

    def takePendingAction(self):
        pending_action = self.__pending_action__
        self.__pending_action__ = None
        return pending_action

class SimPerformTask(smach.State):
    def __init__(self, state_name, input_keys, exec_time_s):
        if exec_time_s is None:
            self.__exec_time_s__ = -1.0
        else:
            self.__exec_time_s__ = float(exec_time_s)
        self.state_name = state_name
        self.__result_outcome__ = 'FINISHED'
        self.__outcomes__ = ['FINISHED', 'PREEMPTED', 'FAILED']

        smach.State.__init__(self, input_keys=input_keys,
                                    outcomes=self.__outcomes__)

    def execute(self, userdata):
        rospy.loginfo('{}: Executing state: {}'.format(rospy.get_name(), self.__class__.__name__))
        print self.state_name + '.execute'

        if self.__exec_time_s__ > 0:
            iterations = int(self.__exec_time_s__*10.0)
            for i in range(iterations):
                if self.preempt_requested():
                    print self.state_name + ': preempt_requested'
                    self.service_preempt()
                    return 'PREEMPTED'
                time.sleep(0.1)
        else:
            while True:
                if self.preempt_requested():
                    print self.state_name + ': preempt_requested'
                    self.service_preempt()
                    return 'PREEMPTED'
                time.sleep(0.1)
        return self.__result_outcome__

    def setResultOutcome(self, result_outcome):
        assert result_outcome in self.__outcomes__
        self.__result_outcome__ = result_outcome

    def setExecTime(self, exec_time_s):
        self.__exec_time_s__ = exec_time_s

#
# 
#

class BehaviourSM(smach.StateMachine):
    def __init__(self, is_simulated, conversation_interface):
        smach.StateMachine.__init__(self, input_keys=['sm_goal'],
                                        outcomes=['PREEMPTED',
                                                    'FAILED',
                                                    'FINISHED'])

        state_dict = {
            'BringGoods': tiago_smach.bring_goods.BringGoods(is_simulated, conversation_interface),
            'MoveTo': tiago_smach.navigation.MoveToComplex(is_simulated),
            'Wander': tiago_smach.wander.Wander(is_simulated),
            }
        '''
        if is_simulated == True:
            state_dict = {
                'BringGoods': SimPerformTask('BringGoods', ['goods_name'], 10.0),
                'MoveTo': SimPerformTask('MoveTo', ['nav_goal_pose'], 10.0),
                'Wander': SimPerformTask('Wander', [ ], None),
                }
        elif is_simulated == False:
            state_dict = {
                'BringGoods': tiago_smach.bring_goods.BringGoods(is_simulated),
                'MoveTo': tiago_smach.navigation.MoveToComplex(is_simulated),
                'Wander': tiago_smach.wander.Wander(is_simulated),
                }
        else:
            raise Exception('Wrong value of arg: "is_simulated": ' + str(is_simulated))
        '''
        with self:
            smach.StateMachine.add('Idle', Idle(['bring_goods', 'move_to', 'wander']),
                                    transitions={
                                        'ok':'FINISHED',
                                        'preemption':'PREEMPTED',
                                        'error': 'FAILED',
                                        'bring_goods':'BringGoods',
                                        'move_to':'MoveTo',
                                        'wander':'Wander'},
                                    remapping={ })

            smach.StateMachine.add('BringGoods', state_dict['BringGoods'],
                                    transitions={'FINISHED':'Idle', 'PREEMPTED':'Idle', 'FAILED': 'Idle'},
                                    remapping={'goods_name':'sm_goal'})

            smach.StateMachine.add('MoveTo', state_dict['MoveTo'],
                                    transitions={'FINISHED':'Idle', 'PREEMPTED':'Idle', 'FAILED': 'Idle'},
                                    remapping={'nav_goal_pose':'sm_goal'})

            smach.StateMachine.add('Wander', state_dict['Wander'],
                                    transitions={'FINISHED':'Idle', 'PREEMPTED':'Idle', 'FAILED': 'Idle'},
                                    remapping={ })

    def updateAction(self, action_name, sm_goal):
        print 'BehaviourSM.updateAction( "' + action_name + '", "' + str(sm_goal) + '"" )'
        if action_name == 'stop':
            print 'active states: ', self.get_active_states()
            if 'Idle' in self.get_active_states():
                print 'Requested "stop", but the current state is "Idle". Nothing to stop'
            else:
                # Preempt the active states
                for state_name in self.get_active_states():
                    # TODO: some concurrent states are not preemptable (e.g. Conversation)
                    st = self.get_children()[state_name]
                    print 'requesting preempt for state ' + state_name
                    st.request_preempt()
        else:
            if 'Idle' in self.get_active_states():
                self.get_children()['Idle'].setPendingAction( action_name, sm_goal )
            else:
                print 'Could not switch to another state when not Idle'

#
# The top-most SM that govenrs the highest-level behaviour.
#
'''
class TestState(smach.State):
    def __init__(self, state_name, exec_time):
        self.state_name = state_name
        self.exec_time = exec_time
        smach.State.__init__(self, output_keys=['sm_goal'],
                                    outcomes=['ok', 'preemption', 'error'])

    def execute(self, userdata):
        rospy.loginfo('{}: Executing state: {}'.format(rospy.get_name(), self.__class__.__name__))
        print self.state_name + '.execute'
        rospy.sleep(self.exec_time)
        return 'ok'

class Test1SM(smach.StateMachine):
    def __init__(self):
        smach.StateMachine.__init__(self, input_keys=['sm_goal'],
                                        outcomes=['PREEMPTED',
                                                    'FAILED',
                                                    'FINISHED'])

        with self:
            smach.StateMachine.add('s1', TestState('Test1_s1', 2.0),
                                    transitions={
                                        'ok':'s2',
                                        'preemption':'PREEMPTED',
                                        'error': 'FAILED'},
                                    remapping={ })

            smach.StateMachine.add('s2', TestState('Test1_s2', 2.0),
                                    transitions={
                                        'ok':'s1',
                                        'preemption':'PREEMPTED',
                                        'error': 'FAILED'},
                                    remapping={ })
'''

class HearState(smach.State):
    def __init__(self, conversation_interface):
        smach.State.__init__(self, output_keys=[],
                                    outcomes=['ok', 'preemption', 'error'])
        self.conversation_interface = conversation_interface
        self.__items__ = set()

    def execute(self, userdata):
        rospy.loginfo('{}: Executing state: {}'.format(rospy.get_name(), self.__class__.__name__))

        while True:
            if self.preempt_requested():
                self.service_preempt()
                return 'preemption'

            unknown_items = set()
            for item in self.__items__:
                if self.conversation_interface.hasRequest( item ):
                    self.conversation_interface.add( item )
                    self.conversation_interface.removeRequest( item )
                else:
                    unknown_items.add( item )
            # TODO: react to unknown items
            self.__items__ = set()
            rospy.sleep(0.1)

        return 'ok'

    def add(self, item):
        self.__items__.add( item )

class ConversationSM(smach.StateMachine):
    def __init__(self, conversation_interface):
        smach.StateMachine.__init__(self, input_keys=['sm_goal'],
                                        outcomes=['PREEMPTED',
                                                    'FAILED',
                                                    'FINISHED'])

        with self:
            smach.StateMachine.add('hear', HearState(conversation_interface),
                                    transitions={
                                        'ok':'hear',
                                        'preemption':'PREEMPTED',
                                        'error': 'FAILED'},
                                    remapping={ })

    def updateAction(self, action_name, sm_goal):
        print 'ConversationSM.updateAction ' + action_name
        self.get_children()['hear'].add( action_name )

        #if conversation_interface.hasRequest()
        #conversation_interface.add
        return
        print 'MainSM.updateAction( "' + action_name + '", "' + str(sm_goal) + '"" )'
        if action_name == 'stop':
            print 'active states: ', self.get_active_states()
            if 'Idle' in self.get_active_states():
                print 'Requested "stop", but the current state is "Idle". Nothing to stop'
            else:
                # Preempt the active states
                for state_name in self.get_active_states():
                    # TODO: some concurrent states are not preemptable (e.g. Conversation)
                    st = self.get_children()[state_name]
                    print 'requesting preempt for state ' + state_name
                    st.request_preempt()
        else:
            if 'Idle' in self.get_active_states():
                self.get_children()['Idle'].setPendingAction( action_name, sm_goal )
            else:
                print 'Could not switch to another state when not Idle'

class ConversationInterface:
    def __init__(self):
        self.__requests__ = set()
        self.__items__ = set()

    def addRequest( self, req ):
        assert not req in self.__requests__
        self.__requests__.add( req )

    def hasRequest( self, req ):
        return req in self.__requests__

    def removeRequest( self, req ):
        assert req in self.__requests__
        self.__requests__.remove( req )

    def has( self, it ):
        return it in self.__items__

    def remove( self, it ):
        assert it in self.__items__
        self.__items__.remove( it )

    def add( self, it ):
        assert not it in self.__items__
        self.__items__.add( it )

class MainSM(smach.Concurrence):
    def __init__(self):
        smach.Concurrence.__init__(self, outcomes=['PREEMPTED',
                                                    'FAILED',
                                                    'FINISHED'],
                                        default_outcome='FINISHED',
                                        outcome_map={'FINISHED':
                                            { 'task':'FINISHED',
                                                'conv':'FINISHED'}})

        conversation_interface = ConversationInterface()

        self.behaviour_sm = BehaviourSM( True, conversation_interface )
        self.conversation_sm = ConversationSM( conversation_interface )

        with self:
            # Add states to the container
            smach.Concurrence.add('task', self.behaviour_sm)
            smach.Concurrence.add('conv', self.conversation_sm)

def test_concurrenceSM():
    rospy.init_node('behaviours_server_test')
    rospy.sleep(1.0)

    sm = MainSM()

    sis = smach_ros.IntrospectionServer('main_server', sm, '/SM_MAIN_SERVER')
    sis.start()

    def thread_function(aa):
        sm.execute()

    thr = threading.Thread(target=thread_function, args=(1,))
    thr.start()
    time.sleep(0.5)

    raw_input('Press [ENTER] to stop.')

    sm.request_preempt()
    thr.join()

    sis.stop()
    print 'test_concurrenceSM: OK'

def test_BehaviourSM():
    # Test the main state machine, without ROS actionlib and with simulated states

    rospy.init_node('behaviours_server_test')
    rospy.sleep(1.0)

    sm = BehaviourSM(True)

    sis = smach_ros.IntrospectionServer('main_server', sm, '/SM_MAIN_SERVER')
    sis.start()

    def thread_function(aa):
        sm.execute()

    thr = threading.Thread(target=thread_function, args=(1,))
    thr.start()
    time.sleep(0.5)

    assert set(sm.get_active_states()) == set(['Idle'])

    sm.updateAction('stop', '')
    time.sleep(0.4)
    assert set(sm.get_active_states()) == set(['Idle'])

#    sm.updateAction('q_load', '')
#    time.sleep(0.1)
#    assert set(sm.get_active_states()) == set(['Idle'])

#    sm.updateAction('q_current_task', '')
#    time.sleep(0.1)
#    assert set(sm.get_active_states()) == set(['Idle'])

    sm.updateAction('bring_goods', 'woda')
    time.sleep(0.5)
    assert set(sm.get_active_states()) == set(['BringGoods'])

    sm.updateAction('bring_goods', 'woda')
    time.sleep(0.5)
    assert set(sm.get_active_states()) == set(['BringGoods'])

    sm.updateAction('stop', '')
    time.sleep(0.5)
    assert set(sm.get_active_states()) == set(['Idle'])

    sm.get_children()['BringGoods'].setExecTime(2.0)
    sm.get_children()['BringGoods'].setResultOutcome('FAILED')
    sm.updateAction('bring_goods', 'woda')
    time.sleep(1.0)
    assert set(sm.get_active_states()) == set(['BringGoods'])
    time.sleep(2.0)
    assert set(sm.get_active_states()) == set(['Idle'])

    sm.get_children()['BringGoods'].setExecTime(2.0)
    sm.get_children()['BringGoods'].setResultOutcome('FINISHED')
    sm.updateAction('bring_goods', 'woda')
    time.sleep(1.0)
    assert set(sm.get_active_states()) == set(['BringGoods'])
    time.sleep(2.0)
    assert set(sm.get_active_states()) == set(['Idle'])

    sm.get_children()['BringGoods'].setExecTime(30.0)
    sm.updateAction('bring_goods', 'woda')
    time.sleep(1.0)
    assert set(sm.get_active_states()) == set(['BringGoods'])

    sm.updateAction('move_to', 'asd')
    time.sleep(1.0)
    assert set(sm.get_active_states()) == set(['BringGoods'])

    sm.updateAction('stop', '')
    time.sleep(1.0)
    assert set(sm.get_active_states()) == set(['Idle'])

    sm.updateAction('move_to', 'asd')
    time.sleep(1.0)
    assert set(sm.get_active_states()) == set(['MoveTo'])

    sm.updateAction('stop', '')
    time.sleep(1.0)
    assert set(sm.get_active_states()) == set(['Idle'])

    sm.updateAction('wander', '')
    time.sleep(1.0)
    assert set(sm.get_active_states()) == set(['Wander'])

    sm.request_preempt()
    time.sleep(1.0)
    assert set(sm.get_active_states()) == set(['Idle'])

    sm.request_preempt()
    thr.join()

    raw_input('.')

    sis.stop()
    print 'test_BehaviourSM: OK'

#
#
#

class ASUniversalState(smach.State):
    def __init__(self, main_sm):
        self.main_sm = main_sm

        smach.State.__init__(self, input_keys=['action_name', 'sm_goal'],
                             outcomes=['ok', 'preemption', 'error'])

    def execute(self, userdata):
        rospy.loginfo('{}: Executing state: {}'.format(rospy.get_name(), self.__class__.__name__))
        self.main_sm.updateAction(userdata.action_name, userdata.sm_goal)
        return 'ok'

class ASUniversal(smach.StateMachine):
    def __init__(self, main_sm, action_name):
        smach.StateMachine.__init__(self, input_keys=['sm_goal'],
                                         outcomes=['PREEMPTED',
                                                    'FAILED',
                                                    'FINISHED'])
        self.userdata.action_name = action_name
        with self:
            smach.StateMachine.add('State', ASUniversalState(main_sm), transitions={'ok':'FINISHED', 'preemption':'PREEMPTED', 'error': 'FAILED'},
                                        remapping={'action_name':'action_name', 'sm_goal':'sm_goal'})

def main():
    rospy.init_node('behaviours_server')
    rospy.sleep(1.0)

    main_sm = MainSM()

    list_sis = []
    sis = smach_ros.IntrospectionServer('behaviour_server', main_sm, '/SM_BEHAVIOUR_SERVER')
    sis.start()
    list_sis.append( sis )

    behaviours = [
        ('wander', WanderAction, main_sm.behaviour_sm),
        ('move_to', MoveToAction, main_sm.behaviour_sm),
        ('bring_goods', BringGoodsAction, main_sm.behaviour_sm),
        ('stop', StopAction, main_sm.behaviour_sm),
        ('q_load', QuestionLoadAction, main_sm.conversation_sm),
        ('q_current_task', QuestionCurrentTaskAction, main_sm.conversation_sm),
        ('ack', AckAction, main_sm.conversation_sm),
        ('ack_i_took', AckItookAction, main_sm.conversation_sm),
        ('ack_i_gave', AckIgaveAction, main_sm.conversation_sm),
    ]

    list_asw = []
    for sm_name, action_class, dest_sm in behaviours:
        # Construct state machine
        sm = ASUniversal(dest_sm, sm_name)

        # # Smach viewer
        sis = smach_ros.IntrospectionServer(sm_name + '_server', sm, '/SM_' + sm_name.upper() + '_SERVER')
        sis.start()
        list_sis.append( sis )

        # Construct action server wrapper
        asw = smach_ros.ActionServerWrapper(
            server_name=sm_name,
            action_spec=action_class,
            wrapped_container=sm,
            succeeded_outcomes=['FINISHED'],
            aborted_outcomes=['FAILED'],
            preempted_outcomes=['PREEMPTED'],
            goal_key='sm_goal')

        # Run the server in a background thread
        asw.run_server()
        list_asw.append( asw )

    main_sm.execute()

    for sis in list_sis:
        sis.stop()

if __name__ == '__main__':
    #test_concurrenceSM()
    #exit(0)
    if len(sys.argv) == 2 and sys.argv[1] == 'test':
        test_BehaviourSM()
    else:
        main()
