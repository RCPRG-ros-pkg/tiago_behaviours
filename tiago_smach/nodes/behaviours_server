#!/usr/bin/env python

import sys
import time
import threading

import rospy
import smach
import smach_ros
from std_msgs.msg import String

from tiago_behaviours_msgs.msg import WanderAction, MoveToAction, BringGoodsAction, StopAction,\
                                        QuestionLoadAction, QuestionCurrentTaskAction,\
                                        AckAction, AckItookAction, AckIgaveAction

import tiago_smach.conversation
import tiago_smach.bring_goods
import tiago_smach.navigation
import tiago_smach.wander

import tiago_kb.places_xml as kb_p

class Idle(smach.State):
    def __init__(self, action_names, conversation_interface):
        outcomes = ['ok', 'preemption', 'error']
        for an in action_names:
            if an in outcomes:
                raise Exception('The action name "' + an + '" is already in outcomes.')
            outcomes.append( an )
        self.__pending_action__ = None
        self.conversation_interface = conversation_interface

        smach.State.__init__(self, output_keys=['sm_goal'],
                                    outcomes=outcomes)

    def execute(self, userdata):
        rospy.loginfo('{}: Executing state: {}'.format(rospy.get_name(), self.__class__.__name__))
        print 'Idle.execute'

        self.conversation_interface.addExpected('q_current_task', False)
        while True:
            #print 'Idle.loop'
            if self.preempt_requested():
                # This state cannot be preempted
                self.service_preempt()
                return 'error'


            if self.conversation_interface.consumeItem('q_current_task'):
                self.conversation_interface.addSpeakSentence( 'Nic nie robie.' )

            if self.hasPendingAction():
                action_name, sm_goal = self.takePendingAction()
                userdata.sm_goal = sm_goal
                print 'Idle: hasPendingAction: ' + action_name
                self.conversation_interface.removeExpected('q_current_task')
                return action_name
            time.sleep(0.1)
        return 'error'

    def setPendingAction(self, action_name, sm_goal):
        self.__pending_action__ = ( action_name, sm_goal )

    def hasPendingAction(self):
        return not self.__pending_action__ is None

    def takePendingAction(self):
        pending_action = self.__pending_action__
        self.__pending_action__ = None
        return pending_action

#
# The SM that govenrs the highest-level behaviour.
#

class BehaviourSM(smach.StateMachine):
    def __init__(self, is_simulated, conversation_interface):
        smach.StateMachine.__init__(self, input_keys=['sm_goal'],
                                        outcomes=['PREEMPTED',
                                                    'FAILED',
                                                    'FINISHED'])

        state_dict = {
            'BringGoods': tiago_smach.bring_goods.BringGoods(is_simulated, conversation_interface),
            'MoveTo': tiago_smach.navigation.MoveToComplex(is_simulated, conversation_interface),
            'Wander': tiago_smach.wander.Wander(is_simulated, conversation_interface),
            }

        with self:
            smach.StateMachine.add('Idle', Idle(['bring_goods', 'move_to', 'wander'], conversation_interface),
                                    transitions={
                                        'ok':'FINISHED',
                                        'preemption':'PREEMPTED',
                                        'error': 'FAILED',
                                        'bring_goods':'BringGoods',
                                        'move_to':'MoveTo',
                                        'wander':'Wander'},
                                    remapping={ })

            smach.StateMachine.add('BringGoods', state_dict['BringGoods'],
                                    transitions={'FINISHED':'Idle', 'PREEMPTED':'Idle', 'FAILED': 'Idle'},
                                    remapping={'goods_name':'sm_goal'})

            smach.StateMachine.add('MoveTo', state_dict['MoveTo'],
                                    transitions={'FINISHED':'Idle', 'PREEMPTED':'Idle', 'FAILED': 'Idle'},
                                    remapping={'nav_goal_pose':'sm_goal'})

            smach.StateMachine.add('Wander', state_dict['Wander'],
                                    transitions={'FINISHED':'Idle', 'PREEMPTED':'Idle', 'FAILED': 'Idle'},
                                    remapping={ })

    def updateAction(self, action_name, sm_goal):
        print 'BehaviourSM.updateAction( "' + action_name + '", "' + str(sm_goal) + '"" )'
        if action_name == 'stop':
            print 'active states: ', self.get_active_states()
            if 'Idle' in self.get_active_states():
                print 'Requested "stop", but the current state is "Idle". Nothing to stop'
            else:
                # Preempt the active states
                for state_name in self.get_active_states():
                    # TODO: some concurrent states are not preemptable (e.g. Conversation)
                    st = self.get_children()[state_name]
                    print 'requesting preempt for state ' + state_name
                    st.request_preempt()
        else:
            if 'Idle' in self.get_active_states():
                self.get_children()['Idle'].setPendingAction( action_name, sm_goal )
            else:
                print 'Could not switch to another state when not Idle'

#
#
#

class MainSM(smach.Concurrence):
    def __init__(self, kb_places):
        smach.Concurrence.__init__(self, outcomes=['PREEMPTED',
                                                    'FAILED',
                                                    'FINISHED'],
                                        default_outcome='FINISHED',
                                        outcome_map={'FINISHED':
                                            { 'task':'FINISHED',
                                                'conv':'FINISHED'}})

        # Create conversation interface that is shared between all states and SMs.
        conversation_interface = tiago_smach.conversation.ConversationInterface()
        # The 'stop' command is valid in every situation, so do not autoremove it.
        conversation_interface.addExpected( 'stop', False )

        self.behaviour_sm = BehaviourSM( True, conversation_interface )
        self.conversation_sm = tiago_smach.conversation.ConversationSM( conversation_interface )

        with self:
            # Add states to the container
            smach.Concurrence.add('task', self.behaviour_sm)
            smach.Concurrence.add('conv', self.conversation_sm)

def test_concurrenceSM():
    rospy.init_node('behaviours_server_test')
    rospy.sleep(1.0)

    sm = MainSM()

    sis = smach_ros.IntrospectionServer('main_server', sm, '/SM_MAIN_SERVER')
    sis.start()

    def thread_function(aa):
        sm.execute()

    thr = threading.Thread(target=thread_function, args=(1,))
    thr.start()
    time.sleep(0.5)

    raw_input('Press [ENTER] to stop.')

    sm.request_preempt()
    thr.join()

    sis.stop()
    print 'test_concurrenceSM: OK'

def test_BehaviourSM():
    # Test the main state machine, without ROS actionlib and with simulated states

    rospy.init_node('behaviours_server_test')
    rospy.sleep(1.0)

    sm = BehaviourSM(True)

    sis = smach_ros.IntrospectionServer('main_server', sm, '/SM_MAIN_SERVER')
    sis.start()

    def thread_function(aa):
        sm.execute()

    thr = threading.Thread(target=thread_function, args=(1,))
    thr.start()
    time.sleep(0.5)

    assert set(sm.get_active_states()) == set(['Idle'])

    sm.updateAction('stop', '')
    time.sleep(0.4)
    assert set(sm.get_active_states()) == set(['Idle'])

#    sm.updateAction('q_load', '')
#    time.sleep(0.1)
#    assert set(sm.get_active_states()) == set(['Idle'])

#    sm.updateAction('q_current_task', '')
#    time.sleep(0.1)
#    assert set(sm.get_active_states()) == set(['Idle'])

    sm.updateAction('bring_goods', 'woda')
    time.sleep(0.5)
    assert set(sm.get_active_states()) == set(['BringGoods'])

    sm.updateAction('bring_goods', 'woda')
    time.sleep(0.5)
    assert set(sm.get_active_states()) == set(['BringGoods'])

    sm.updateAction('stop', '')
    time.sleep(0.5)
    assert set(sm.get_active_states()) == set(['Idle'])

    sm.get_children()['BringGoods'].setExecTime(2.0)
    sm.get_children()['BringGoods'].setResultOutcome('FAILED')
    sm.updateAction('bring_goods', 'woda')
    time.sleep(1.0)
    assert set(sm.get_active_states()) == set(['BringGoods'])
    time.sleep(2.0)
    assert set(sm.get_active_states()) == set(['Idle'])

    sm.get_children()['BringGoods'].setExecTime(2.0)
    sm.get_children()['BringGoods'].setResultOutcome('FINISHED')
    sm.updateAction('bring_goods', 'woda')
    time.sleep(1.0)
    assert set(sm.get_active_states()) == set(['BringGoods'])
    time.sleep(2.0)
    assert set(sm.get_active_states()) == set(['Idle'])

    sm.get_children()['BringGoods'].setExecTime(30.0)
    sm.updateAction('bring_goods', 'woda')
    time.sleep(1.0)
    assert set(sm.get_active_states()) == set(['BringGoods'])

    sm.updateAction('move_to', 'asd')
    time.sleep(1.0)
    assert set(sm.get_active_states()) == set(['BringGoods'])

    sm.updateAction('stop', '')
    time.sleep(1.0)
    assert set(sm.get_active_states()) == set(['Idle'])

    sm.updateAction('move_to', 'asd')
    time.sleep(1.0)
    assert set(sm.get_active_states()) == set(['MoveTo'])

    sm.updateAction('stop', '')
    time.sleep(1.0)
    assert set(sm.get_active_states()) == set(['Idle'])

    sm.updateAction('wander', '')
    time.sleep(1.0)
    assert set(sm.get_active_states()) == set(['Wander'])

    sm.request_preempt()
    time.sleep(1.0)
    assert set(sm.get_active_states()) == set(['Idle'])

    sm.request_preempt()
    thr.join()

    raw_input('.')

    sis.stop()
    print 'test_BehaviourSM: OK'

#
#
#

class ASUniversalState(smach.State):
    def __init__(self, main_sm):
        self.main_sm = main_sm

        smach.State.__init__(self, input_keys=['action_name', 'sm_goal'],
                             outcomes=['ok', 'preemption', 'error'])

    def execute(self, userdata):
        rospy.loginfo('{}: Executing state: {}'.format(rospy.get_name(), self.__class__.__name__))
        self.main_sm.updateAction(userdata.action_name, userdata.sm_goal)
        return 'ok'

class ASUniversal(smach.StateMachine):
    def __init__(self, main_sm, action_name):
        smach.StateMachine.__init__(self, input_keys=['sm_goal'],
                                         outcomes=['PREEMPTED',
                                                    'FAILED',
                                                    'FINISHED'])
        self.userdata.action_name = action_name
        with self:
            smach.StateMachine.add('State', ASUniversalState(main_sm), transitions={'ok':'FINISHED', 'preemption':'PREEMPTED', 'error': 'FAILED'},
                                        remapping={'action_name':'action_name', 'sm_goal':'sm_goal'})

def main():
    rospy.init_node('behaviours_server')
    rospy.sleep(0.5)

    places_xml_filename = rospy.get_param('~places_xml')
    print 'Reading KB for places from file "' + places_xml_filename + '"'
    kb_places = kb_p.PlacesXml(places_xml_filename)

    main_sm = MainSM( kb_places )

    list_sis = []
    sis = smach_ros.IntrospectionServer('behaviour_server', main_sm, '/SM_BEHAVIOUR_SERVER')
    sis.start()
    list_sis.append( sis )

    behaviours = [
        ('wander', WanderAction, main_sm.behaviour_sm),
        ('move_to', MoveToAction, main_sm.behaviour_sm),
        ('bring_goods', BringGoodsAction, main_sm.behaviour_sm),
        ('stop', StopAction, main_sm.behaviour_sm),
        ('q_load', QuestionLoadAction, main_sm.conversation_sm),
        ('q_current_task', QuestionCurrentTaskAction, main_sm.conversation_sm),
        ('ack', AckAction, main_sm.conversation_sm),
        ('ack_i_took', AckItookAction, main_sm.conversation_sm),
        ('ack_i_gave', AckIgaveAction, main_sm.conversation_sm),
    ]

    list_asw = []
    for sm_name, action_class, dest_sm in behaviours:
        # Construct state machine
        sm = ASUniversal(dest_sm, sm_name)

        # # Smach viewer
        sis = smach_ros.IntrospectionServer(sm_name + '_server', sm, '/SM_' + sm_name.upper() + '_SERVER')
        sis.start()
        list_sis.append( sis )

        # Construct action server wrapper
        asw = smach_ros.ActionServerWrapper(
            server_name=sm_name,
            action_spec=action_class,
            wrapped_container=sm,
            succeeded_outcomes=['FINISHED'],
            aborted_outcomes=['FAILED'],
            preempted_outcomes=['PREEMPTED'],
            goal_key='sm_goal')

        # Run the server in a background thread
        asw.run_server()
        list_asw.append( asw )

    main_sm.execute()

    for sis in list_sis:
        sis.stop()

if __name__ == '__main__':
    #test_concurrenceSM()
    #exit(0)
    if len(sys.argv) == 2 and sys.argv[1] == 'test':
        test_BehaviourSM()
    else:
        main()
