#!/usr/bin/env python
# encoding: utf8

import sys
import time
import threading

import rospy
import smach
import smach_ros
from std_msgs.msg import String

from tiago_behaviours_msgs.msg import WanderAction, MoveToAction, BringGoodsAction, StopAction,\
                                        QuestionLoadAction, QuestionCurrentTaskAction,\
                                        AckAction, AckItookAction, AckIgaveAction

import tiago_smach.conversation
import tiago_smach.bring_goods
import tiago_smach.navigation
import tiago_smach.wander
import tiago_smach.smach_rcprg as smach_rcprg

import tiago_kb.places_xml as kb_p

class Idle(smach_rcprg.State):
    def __init__(self, action_names, conversation_interface, kb_places):
        outcomes = ['ok', 'preemption', 'error', 'shutdown']
        for an in action_names:
            if an in outcomes:
                raise Exception('The action name "' + an + '" is already in outcomes.')
            outcomes.append( an )
        self.__pending_action__ = None
        self.conversation_interface = conversation_interface

        smach_rcprg.State.__init__(self, output_keys=['action_goal'],
                                    outcomes=outcomes)

    def execute(self, userdata):
        rospy.loginfo('{}: Executing state: {}'.format(rospy.get_name(), self.__class__.__name__))
        print 'Idle.execute'

        self.conversation_interface.addExpected('q_current_task', False)
        while True:
            if self.__shutdown__:
                return 'shutdown'

            if self.preempt_requested():
                # This state can be preempted only on shutdown
                self.service_preempt()
                return 'error'

            if self.conversation_interface.consumeItem('q_current_task'):
                self.conversation_interface.addSpeakSentence( u'Nic nie robiÄ™.' )

            if self.hasPendingAction():
                action_name, action_goal = self.takePendingAction()
                userdata.action_goal = action_goal
                print 'Idle: hasPendingAction: ' + action_name
                self.conversation_interface.removeExpected('q_current_task')
                return action_name

            #try:
            rospy.sleep(0.1)
            #except rospy.ROSInterruptException:
            #    return 'error'
        return 'error'

    def setPendingAction(self, action_name, action_goal):
        self.__pending_action__ = ( action_name, action_goal )

    def hasPendingAction(self):
        return not self.__pending_action__ is None

    def takePendingAction(self):
        pending_action = self.__pending_action__
        self.__pending_action__ = None
        return pending_action

#
# The SM that govenrs the highest-level behaviour.
#

class BehaviourSM(smach_rcprg.StateMachine):
    def __init__(self, sim_mode, conversation_interface, kb_places):
        smach_rcprg.StateMachine.__init__(self, outcomes=['PREEMPTED',
                                                    'FAILED',
                                                    'FINISHED', 'shutdown'])

        with self:
            smach_rcprg.StateMachine.add('Idle', Idle(['bring_goods', 'move_to', 'wander'], conversation_interface, kb_places),
                                    transitions={
                                        'ok':'FINISHED',
                                        'preemption':'PREEMPTED',
                                        'error': 'FAILED',
                                        'shutdown':'shutdown',
                                        'bring_goods':'BringGoods',
                                        'move_to':'MoveTo',
                                        'wander':'Wander'},
                                    remapping={ })

            smach_rcprg.StateMachine.add('BringGoods',
                                    tiago_smach.bring_goods.BringGoods(sim_mode, conversation_interface, kb_places),
                                    transitions={'FINISHED':'Idle', 'PREEMPTED':'Idle', 'FAILED': 'Idle',
                                    'shutdown':'shutdown'},
                                    remapping={'goods_name':'action_goal'})

            smach_rcprg.StateMachine.add('MoveTo',
                                    tiago_smach.navigation.MoveToComplexTorsoMid(sim_mode, conversation_interface, kb_places),
                                    transitions={'FINISHED':'Idle', 'PREEMPTED':'Idle', 'FAILED': 'Idle',
                                    'shutdown':'shutdown'},
                                    remapping={'nav_goal_pose':'action_goal'})

            smach_rcprg.StateMachine.add('Wander',
                                    tiago_smach.wander.Wander(sim_mode, conversation_interface, kb_places),
                                    transitions={'FINISHED':'Idle', 'PREEMPTED':'Idle', 'FAILED': 'Idle',
                                    'shutdown':'shutdown'},
                                    remapping={ })

    def updateAction(self, action_name, action_goal):
        print 'BehaviourSM.updateAction( "' + action_name + '", "' + str(action_goal) + '"" )'
        if action_name == 'stop':
            print 'active states: ', self.get_active_states()
            if 'Idle' in self.get_active_states():
                print 'Requested "stop", but the current state is "Idle". Nothing to stop'
            else:
                # Preempt the active states
                for state_name in self.get_active_states():
                    # TODO: some concurrent states are not preemptable (e.g. Conversation)
                    st = self.get_children()[state_name]
                    print 'requesting preempt for state ' + state_name
                    st.request_preempt()
        else:
            if 'Idle' in self.get_active_states():
                self.get_children()['Idle'].setPendingAction( action_name, action_goal )
            else:
                print 'Could not switch to another state when not Idle'

#
#
#

class MainSM(smach.Concurrence):
    def __init__(self, sim_mode, kb_places):
        smach.Concurrence.__init__(self, outcomes=['PREEMPTED',
                                                    'FAILED',
                                                    'FINISHED'],
                                        default_outcome='FINISHED',
                                        outcome_map={'FINISHED':
                                            { 'task':'FINISHED',
                                                'conv':'FINISHED'}})

        # Create conversation interface that is shared between all states and SMs.
        conversation_interface = tiago_smach.conversation.ConversationInterface()
        # The 'stop' command is valid in every situation, so do not autoremove it.
        conversation_interface.addExpected( 'stop', False )

        self.behaviour_sm = BehaviourSM( sim_mode, conversation_interface, kb_places )
        self.conversation_sm = tiago_smach.conversation.ConversationSM( conversation_interface )

        with self:
            # Add states to the container
            smach.Concurrence.add('task', self.behaviour_sm)
            smach.Concurrence.add('conv', self.conversation_sm)

    def shutdownRequest(self):
        self.behaviour_sm.shutdownRequest()
        self.conversation_sm.shutdownRequest()
        self.request_preempt()

#    def on_shutdown(self):
#        print 'MainSM.on_shutdown()'
#        self.request_preempt()
#        rospy.sleep(1.0)

def test_concurrenceSM():
    rospy.init_node('behaviours_server_test')
    rospy.sleep(1.0)

    sm = MainSM()

    sis = smach_ros.IntrospectionServer('main_server', sm, '/SM_MAIN_SERVER')
    sis.start()

    def thread_function(aa):
        sm.execute()

    thr = threading.Thread(target=thread_function, args=(1,))
    thr.start()
    time.sleep(0.5)

    raw_input('Press [ENTER] to stop.')

    sm.request_preempt()
    thr.join()

    sis.stop()
    print 'test_concurrenceSM: OK'

def test_BehaviourSM():
    # Test the main state machine, without ROS actionlib and with simulated states

    rospy.init_node('behaviours_server_test')
    rospy.sleep(1.0)

    sm = BehaviourSM(True)

    sis = smach_ros.IntrospectionServer('main_server', sm, '/SM_MAIN_SERVER')
    sis.start()

    def thread_function(aa):
        sm.execute()

    thr = threading.Thread(target=thread_function, args=(1,))
    thr.start()
    time.sleep(0.5)

    assert set(sm.get_active_states()) == set(['Idle'])

    sm.updateAction('stop', '')
    time.sleep(0.4)
    assert set(sm.get_active_states()) == set(['Idle'])

#    sm.updateAction('q_load', '')
#    time.sleep(0.1)
#    assert set(sm.get_active_states()) == set(['Idle'])

#    sm.updateAction('q_current_task', '')
#    time.sleep(0.1)
#    assert set(sm.get_active_states()) == set(['Idle'])

    sm.updateAction('bring_goods', 'woda')
    time.sleep(0.5)
    assert set(sm.get_active_states()) == set(['BringGoods'])

    sm.updateAction('bring_goods', 'woda')
    time.sleep(0.5)
    assert set(sm.get_active_states()) == set(['BringGoods'])

    sm.updateAction('stop', '')
    time.sleep(0.5)
    assert set(sm.get_active_states()) == set(['Idle'])

    sm.get_children()['BringGoods'].setExecTime(2.0)
    sm.get_children()['BringGoods'].setResultOutcome('FAILED')
    sm.updateAction('bring_goods', 'woda')
    time.sleep(1.0)
    assert set(sm.get_active_states()) == set(['BringGoods'])
    time.sleep(2.0)
    assert set(sm.get_active_states()) == set(['Idle'])

    sm.get_children()['BringGoods'].setExecTime(2.0)
    sm.get_children()['BringGoods'].setResultOutcome('FINISHED')
    sm.updateAction('bring_goods', 'woda')
    time.sleep(1.0)
    assert set(sm.get_active_states()) == set(['BringGoods'])
    time.sleep(2.0)
    assert set(sm.get_active_states()) == set(['Idle'])

    sm.get_children()['BringGoods'].setExecTime(30.0)
    sm.updateAction('bring_goods', 'woda')
    time.sleep(1.0)
    assert set(sm.get_active_states()) == set(['BringGoods'])

    sm.updateAction('move_to', 'asd')
    time.sleep(1.0)
    assert set(sm.get_active_states()) == set(['BringGoods'])

    sm.updateAction('stop', '')
    time.sleep(1.0)
    assert set(sm.get_active_states()) == set(['Idle'])

    sm.updateAction('move_to', 'asd')
    time.sleep(1.0)
    assert set(sm.get_active_states()) == set(['MoveTo'])

    sm.updateAction('stop', '')
    time.sleep(1.0)
    assert set(sm.get_active_states()) == set(['Idle'])

    sm.updateAction('wander', '')
    time.sleep(1.0)
    assert set(sm.get_active_states()) == set(['Wander'])

    sm.request_preempt()
    time.sleep(1.0)
    assert set(sm.get_active_states()) == set(['Idle'])

    sm.request_preempt()
    thr.join()

    raw_input('.')

    sis.stop()
    print 'test_BehaviourSM: OK'

#
#
#

class ASUniversalState(smach.State):
    def __init__(self, main_sm):
        self.main_sm = main_sm

        smach.State.__init__(self, input_keys=['action_name', 'sm_goal'],
                             outcomes=['ok', 'preemption', 'error'])

    def execute(self, userdata):
        rospy.loginfo('{}: Executing state: {}'.format(rospy.get_name(), self.__class__.__name__))
        self.main_sm.updateAction(userdata.action_name, userdata.sm_goal)
        return 'ok'

class ASUniversal(smach.StateMachine):
    def __init__(self, main_sm, action_name):
        smach.StateMachine.__init__(self, input_keys=['sm_goal'],
                                         outcomes=['PREEMPTED',
                                                    'FAILED',
                                                    'FINISHED'])
        self.userdata.action_name = action_name
        with self:
            smach.StateMachine.add('State', ASUniversalState(main_sm), transitions={'ok':'FINISHED', 'preemption':'PREEMPTED', 'error': 'FAILED'},
                                        remapping={'action_name':'action_name', 'sm_goal':'sm_goal'})

class SmachShutdownManager:
    def __init__(self, main_sm, list_asw, list_sis):
        self.__main_sm__ = main_sm
        self.__list_asw__ = list_asw
        self.__list_sis__ = list_sis

    def on_shutdown(self):
        # Stop all introspection servers
        print 'SmachShutdownManager.on_shutdown: stopping all introspection servers'
        for sis in reversed(self.__list_sis__):
            sis.stop()

        # Stop all smach_ros action servers
        print 'SmachShutdownManager.on_shutdown: stopping all smach_ros action servers'
        for asw in reversed(self.__list_asw__):
            # This is a veru ugly hack:
            asw._action_server.action_server.started = False

            asw.wrapped_container.request_preempt()

        # Stop the main SM
        print 'SmachShutdownManager.on_shutdown: stopping the main SM'
        self.__main_sm__.request_preempt()

        rospy.sleep(2.0)

def main():
    rospy.init_node('behaviours_server')
    rospy.sleep(0.5)

    places_xml_filename = rospy.get_param('~places_xml')
    sim_mode = str(rospy.get_param('~sim_mode'))
    assert sim_mode in ['sim', 'gazebo', 'real']

    print 'Reading KB for places from file "' + places_xml_filename + '"'
    kb_places = kb_p.PlacesXmlParser(places_xml_filename).getKB()

    main_sm = MainSM( sim_mode, kb_places )

    list_sis = []
    sis_main = smach_ros.IntrospectionServer('behaviour_server', main_sm, '/SM_BEHAVIOUR_SERVER')
    sis_main.start()
    list_sis.append(sis_main)

    behaviours = [
        ('wander', WanderAction, main_sm.behaviour_sm),
        ('move_to', MoveToAction, main_sm.behaviour_sm),
        ('bring_goods', BringGoodsAction, main_sm.behaviour_sm),
        ('stop', StopAction, main_sm.behaviour_sm),
        ('q_load', QuestionLoadAction, main_sm.conversation_sm),
        ('q_current_task', QuestionCurrentTaskAction, main_sm.conversation_sm),
        ('ack', AckAction, main_sm.conversation_sm),
        ('ack_i_took', AckItookAction, main_sm.conversation_sm),
        ('ack_i_gave', AckIgaveAction, main_sm.conversation_sm),
    ]

    list_asw = []
    for sm_name, action_class, dest_sm in behaviours:
        # Construct state machine
        sm = ASUniversal(dest_sm, sm_name)

        # # Smach viewer
        sis = smach_ros.IntrospectionServer(sm_name + '_server', sm, '/SM_' + sm_name.upper() + '_SERVER')
        sis.start()
        list_sis.append( sis )

        # Construct action server wrapper
        asw = smach_ros.ActionServerWrapper(
            server_name=sm_name,
            action_spec=action_class,
            wrapped_container=sm,
            succeeded_outcomes=['FINISHED'],
            aborted_outcomes=['FAILED'],
            preempted_outcomes=['PREEMPTED'],
            goal_key='sm_goal')

        # Run the server in a background thread
        asw.run_server()
        list_asw.append( asw )

    ssm = SmachShutdownManager(main_sm, list_asw, list_sis)

    # Set shutdown hook
    rospy.on_shutdown( ssm.on_shutdown )

    smach_thread = threading.Thread(target=main_sm.execute)
    smach_thread.start()

    # Wait for ctrl-c
    rospy.spin()

    # Block until everything is preempted
    smach_thread.join()

if __name__ == '__main__':
    #test_concurrenceSM()
    #exit(0)
    if len(sys.argv) == 2 and sys.argv[1] == 'test':
        test_BehaviourSM()
    else:
        main()
